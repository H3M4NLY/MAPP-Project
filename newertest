#include <cstdio>
#include <cctype>
#include <cstdlib>
#undef __ARM_FP

#include "mbed.h"
#include "lcd.h"	
#include "keypad.h"	

#define DISPLAY_BAR_MASK 0x000000FF 	//PORT C0: PC_7 - PC_0
#define DISPLAY_BAR_RESET 0x00000000

#define NOTE_B0  31
#define NOTE_C1  33
#define NOTE_CS1 35
#define NOTE_D1  37
#define NOTE_DS1 39
#define NOTE_E1  41
#define NOTE_F1  44
#define NOTE_FS1 46
#define NOTE_G1  49
#define NOTE_GS1 52
#define NOTE_A1  55
#define NOTE_AS1 58
#define NOTE_B1  62
#define NOTE_C2  65
#define NOTE_CS2 69
#define NOTE_D2  73
#define NOTE_DS2 78
#define NOTE_E2  82
#define NOTE_F2  87
#define NOTE_FS2 93
#define NOTE_G2  98
#define NOTE_GS2 104
#define NOTE_A2  110
#define NOTE_AS2 117
#define NOTE_B2  123
#define NOTE_C3  131
#define NOTE_CS3 139
#define NOTE_D3  147
#define NOTE_DS3 156
#define NOTE_E3  165
#define NOTE_F3  175
#define NOTE_FS3 185
#define NOTE_G3  196
#define NOTE_GS3 208
#define NOTE_A3  220
#define NOTE_AS3 233
#define NOTE_B3  247
#define NOTE_C4  262
#define NOTE_CS4 277
#define NOTE_D4  294
#define NOTE_DS4 311
#define NOTE_E4  330
#define NOTE_F4  349
#define NOTE_FS4 370
#define NOTE_G4  392
#define NOTE_GS4 415
#define NOTE_A4  440
#define NOTE_AS4 466
#define NOTE_B4  494
#define NOTE_C5  523
#define NOTE_CS5 554
#define NOTE_D5  587
#define NOTE_DS5 622
#define NOTE_E5  659
#define NOTE_F5  698
#define NOTE_FS5 740
#define NOTE_G5  784
#define NOTE_GS5 831
#define NOTE_A5  880
#define NOTE_AS5 932
#define NOTE_B5  988
#define NOTE_C6  1047
#define NOTE_CS6 1109
#define NOTE_D6  1175
#define NOTE_DS6 1245
#define NOTE_E6  1319
#define NOTE_F6  1397
#define NOTE_FS6 1480
#define NOTE_G6  1568
#define NOTE_GS6 1661
#define NOTE_A6  1760
#define NOTE_AS6 1865
#define NOTE_B6  1976
#define NOTE_C7  2093
#define NOTE_CS7 2217
#define NOTE_D7  2349
#define NOTE_DS7 2489
#define NOTE_E7  2637
#define NOTE_F7  2794
#define NOTE_FS7 2960
#define NOTE_G7  3136
#define NOTE_GS7 3322
#define NOTE_A7  3520
#define NOTE_AS7 3729
#define NOTE_B7  3951
#define NOTE_C8  4186
#define NOTE_CS8 4435
#define NOTE_D8  4699
#define NOTE_DS8 4978

AnalogIn moistureSensor(PA_0);
DigitalOut waterPump(PA_5);
PwmOut Motor1(PA_6);
PwmOut Motor2(PA_7);
PwmOut buzzer(PA_9);
//Declare the GPIO pins for the Switch as DigitalIn type

BusOut leds(PB_0);  
BusOut led2(PB_1);

PortOut displayBarPort(PortC, DISPLAY_BAR_MASK);

char bruh;
char lmao = 0;
char settime = 0;

unsigned char key, outChar;
unsigned char status = '0';
unsigned char pumpfreq[10];

char moistureStr[10];
char Message1 [ ] = "Select Option:      ";
char Message2 [ ] = "Mode 1              ";	  
char Message3 [ ] = "Mode 2              ";	  
char Message4 [ ] = "Invalid. Loser.     ";  
char Message5 [] =  "Moisture: ";
char TimeMessage1 [] = "Frequency Mode: ";



Ticker pumpTicker;
Ticker moistureTicker;
Ticker readMoistureTicker;
Ticker bruhTicker;
Ticker tickerticker;
Timer timer;


int pump_frequency = 0;
int melody[] = {
    NOTE_D4, NOTE_E4, NOTE_A4, NOTE_FS4, NOTE_D4, NOTE_G4, NOTE_A4, NOTE_FS4,
    NOTE_B4, NOTE_A4, NOTE_FS4, NOTE_D4, NOTE_D4, NOTE_E4, NOTE_G4, NOTE_FS4
};

int noteDurations[] = {
    8, 8, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 8, 8, 4, 4
};
int clear = 0;

float moisturePercentage; // Global variable to store the moisture percentage

// Function to simulate reading the moisture sensor
void read_moisture_sensor() {
    float moistureValue = moistureSensor.read();
    float moisturePercentage = moistureValue * 100.0;
    printf("Moisture percentage: %.2f\n", moisturePercentage);
    sprintf(moistureStr, "%.2f", moisturePercentage);
    strcat(Message5, moistureStr);
    snprintf(Message5, sizeof(Message5), "Moisture: %.2f", moisturePercentage);
    
}

void control_water_pump(bool turn_on) {
    waterPump = turn_on ? 1 : 0; // Turn the pump on or off
    printf("Pump should work. \n");
}

void toggle_water_pump() {
    static bool pump_state = false;
    pump_state = !pump_state;
    control_water_pump(pump_state);
    printf("idk \n");
}

void stop_servo1() {
    Motor1.period(0.02f);
    Motor1.write(0.0f);   // 0% duty cycle (Suspending servo movement)
    printf("Servo 1 stopped\n");
}

// Function to set the first servo motor forward
void set_servo1_forward() {
    stop_servo1();
    Motor1.period(0.02f);   // 20ms period (standard for servos)
    Motor1.write(0.10f);    // 10% duty cycle (forward position)
    printf("Servo 1 set to forward position\n");
    stop_servo1();
}

// Function to set the first servo motor backward
void set_servo1_backward() {
    stop_servo1();
    Motor1.period(0.02f);   // 20ms period (standard for servos)
    Motor1.write(0.05f);    // 5% duty cycle (backward position)
    printf("Servo 1 set to backward position\n");
    stop_servo1();
}

void stop_servo2() {
    Motor2.period(0.02f);
    Motor2.write(0.0f);   // 0% duty cycle (Suspending servo movement)
    printf("Servo 2 stopped\n");
}


// Function to set the second servo motor forward
void set_servo2_forward() {
    stop_servo2();
    Motor2.period(0.02f);   // 20ms period (standard for servos)
    Motor2.write(0.10f);    // 10% duty cycle (forward position)
    printf("Servo 2 set to forward position\n");
    stop_servo2();
}

// Function to set the second servo motor backward
void set_servo2_backward() {
    stop_servo2();
    Motor2.period(0.02f);   // 20ms period (standard for servos)
    Motor2.write(0.05f);    // 5% duty cycle (backward position)
    stop_servo2();
    printf("Servo 2 set to backward position\n");

}

void playRickAstley() {
    for (int thisNote = 0; thisNote < sizeof(melody) / sizeof(melody[0]); thisNote++) {
        int noteDuration = 1000 / noteDurations[thisNote];
        buzzer.period(1.0 / melody[thisNote]);
        buzzer.write(0.5); // 50% duty cycle for the square wave
        
        thread_sleep_for(noteDuration);
        
        buzzer.write(0.0); // Turn off the buzzer
        thread_sleep_for(noteDuration * 0.3); // Pause between notes
    }
}

void check_moisture(){
    if (moisturePercentage >= 50 && lmao == 0){
                leds = 0;
                led2 = 1;
                 while(timer.read()<= 2){
                    set_servo1_forward();
                    set_servo2_forward();
                 }
                timer.stop();
                if (timer.read()>2){
                    stop_servo1();
                    stop_servo2();
                }
                timer.reset();
                lmao = 1;
                playRickAstley();
             }
    else if (moisturePercentage <= 50 && lmao == 1)
            {
                leds = 0;
                led2 = 1;
                while(timer.read()<= 2){
                    set_servo1_backward();
                    set_servo2_backward();
                }
                timer.stop();
                if (timer.read()>2){
                    stop_servo1();
                    stop_servo2();
                }
                timer.reset();
                lmao = 0;
            }
}

/*void check_bruh()
{   
    printf("Checking bruh: %d\n", bruh);
    if (bruh == 1)
    {
        pumpTicker.attach(&toggle_water_pump, 5000ms);
    }
    else if (bruh == 2)
    {
        pumpTicker.attach(&toggle_water_pump, 10000ms);
    }
    else if (bruh == 3)
    {
        pumpTicker.detach();
    }
} */

void pumpcheck(){
    printf("Checking integer : %d \n", pump_frequency);
    if (pump_frequency == 0){
        pumpTicker.detach();
    }

    else{
        pumpTicker.attach(&toggle_water_pump, pump_frequency);
    }
}

bool isValidInteger(const unsigned char* pumpfreq, int length) {
    for (int i = 0; i < length; i++) {
        if (!isdigit(pumpfreq[i])) {
            return false;
        }
    }
    return true;
}

void displaySelectOption() {
    lcd_write_cmd(0x01); // Clear the LCD
    lcd_write_cmd(0x80); // Move cursor to line 1 position 1
    for (int i = 0; i < 20; i++) //for 20 char LCD module
    {
        outChar = Message1[i];
        lcd_write_data(outChar); // write character data to LCD
    }  
}

// ---- Main Program ---------------------------------------------------------------
int main( )
{
    

	int i;
	lcd_init();	 // Initialise LCD module

    moistureTicker.attach(&read_moisture_sensor, 5000ms);
    readMoistureTicker.attach(&check_moisture, 5000ms);
    // bruhTicker.attach(&check_bruh, 2500ms);
    tickerticker.attach(&pumpcheck, 2500ms);

    char status;
    lcd_write_cmd(0x80); // Move cursor to line 1 position 1
    for (i = 0; i < 20; i++) //for 20 char LCD module
    {
        outChar = Message1[i];
        lcd_write_data(outChar); // write character data to LCD
    }  

    while(true)
        {
            status = getkey();
            //display the PIN keyed in on LCD
            //lcd_write_data(status);
            //lcd_write_cmd(0x01);
            lcd_write_cmd(0xC0); // Move cursor to line 2 position 1

            // Add a delay to avoid flooding the console with messages
            thread_sleep_for(50);


            if (status == '1')
            {
                if (clear == 1){
                    lcd_write_cmd(0x01);
                }
                bruh = 1;
                settime = 1;
                while (settime == 1) {
                    lcd_write_cmd(0x80); // Move cursor to line 1 position 1
                    for (i = 0; i < 16; i++) {
                        outChar = TimeMessage1[i];
                        lcd_write_data(outChar);
                        thread_sleep_for(50);
                    }
                    lcd_write_cmd(0xC0);

                    // Clear pumpfreq array
                    memset(pumpfreq, 0, sizeof(pumpfreq));
                    int freqIndex = 0;
                    bool validInput = true;

                    // Get user input
                    for (int i = 0; i < 10; i++) {
                        char key = getkey();
                        if (key == 'C') {
                            if (freqIndex == 0) {
                                validInput = false;
                                break;  // 'C' pressed before any digit was entered
                            }
                            break;  // Exit loop on 'C' (Enter key)
                        }
                        if (key >= '0' && key <= '9') {
                            pumpfreq[freqIndex++] = key;
                            lcd_write_data(key);
                        } else {
                            validInput = false;
                            break;  // Invalid input
                        }
                    }

                    if (validInput && freqIndex > 0) {
                        pumpfreq[freqIndex] = '\0';  // Null-terminate the string
                        pump_frequency = 0;
                        // Convert the valid input into an integer manually
                        for (int i = 0; i < freqIndex; i++) {
                            pump_frequency = pump_frequency * 10 + (pumpfreq[i] - '0');
                        }

                        // Display the entered frequency for confirmation
                        lcd_write_cmd(0xC0); // Move cursor to line 2 position 1
                        char confirmationMessage[20];
                        sprintf(confirmationMessage, "Frequency: %d", pump_frequency);
                        for (int i = 0; i < strlen(confirmationMessage); i++) {
                            lcd_write_data(confirmationMessage[i]);
                        }

                        thread_sleep_for(2500);
                        settime = 0;
                        displaySelectOption();
                 
                        
                    }               
                
                    else {
                        // Display error message
                        lcd_write_cmd(0xC0); // Move cursor to line 2 position 1
                        char errorMessage[] = "Invalid input!";
                        for (int i = 0; i < strlen(errorMessage); i++) {
                            lcd_write_data(errorMessage[i]);
                        }
                        thread_sleep_for(2000);  // Delay to show the error message
                        lcd_write_cmd(0x01);     // Clear LCD
                    }
                 }
            }
            else if (status == '2')
            {
                if (clear == 1){
                    displaySelectOption();
                    clear = 0;
                }
                lcd_write_cmd(0xC0);
                char stuff[20];
                sprintf(stuff, "Moisture: %f", moisturePercentage);
                for (int i = 0; i < strlen(stuff); i++) {
                    lcd_write_data(stuff[i]);
                }
                clear = 1;
            }


            else 
            {
                if (clear == 1){
                    displaySelectOption();
                    clear = 0;
                }
                lcd_write_cmd(0xC0);
                for (i = 0; i < 20; i++)		//for 20 number
                { 
                    outChar = Message4[i];
                    lcd_write_data(outChar);
                    thread_sleep_for(50);
                }  
                playRickAstley();
                bruh = 3;
                clear = 1;
                thread_sleep_for(1000);
                displaySelectOption();

                /* timer.start();
                while(timer.read() <= 2){
                    set_servo1_forward();
                    stop_servo1();
                }
                timer.stop();
                    if (timer.read() >= 2){
                        stop_servo1();

                }
                timer.stop();
                timer.reset(); 
                timer.start();  
                while(timer.read()<= 2){
                    stop_servo1();
                    set_servo1_backward();
                }
                timer.stop();
                if (timer.read() >=2){
                    stop_servo1();

                }
                timer.reset();    
            */
            }
        }
}
